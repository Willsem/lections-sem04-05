# Объектно-ориентированное программирование

**Тассов Кирилл Леонидович**

## Лекция 1

### Структурное программирование

* Нисходящая разработка
* Использование базовых логических структур
* Сквозной структурный контроль

`вход → f → выход`<br>
Мы думаем что они делают, а не как они это делают.

Разработка разбивает на подзадачи (↓)<br>
Логика совмещает (↑)<br>
Данные приблизить к действию (↓)

#### Что дает эта технология

* Логические ошибки исправляются на ранних стадиях
* За счет упрощения абстракции упрощается написание кода
* Повышается надежность программного продукта
* Повторное использование кода
* Плавное распределение ресурсов при разработке ПО
* Упрощается сопровождение кода
* Возникает много естественных контрольных точек

## Лекция 2

### Инкапсуляция

**Инкапсуляция** – это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали 
реализации от пользователя.

Внесение изменений в написанный код - это понижение надежности

### Наследование

**Наследование** – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциольностью. Класс, от которого производится наследование, называется базовым или родительским. Новый класс – потомком, наследником или производным классом.

### Типы взаимодействий по Хоару

1. Синхронное взаимодействие *(процессорное)*
2. Событийное взаимодействие *(асинхронное)*

**Объект** - конкретная реализация какого-либо понятия, обладающая характеристиками состояния, поведения, индивидуальности.

* __Состояние__ - один из возможных варианта существования объекта
* __Поведение__ - описание объекта в терминах изменения его состояний и передачи сообщений данных в процессе воздействия или под воздействием других объектов
* __Индивидуальность__ - сущность объекта, отличающего его от других объектов

### Модель состояний Мура

Формировать жизненный цикл объекта

1. Выделяем множество состояний в которых может находится объект
2. Выделяем множество событий на которые может реагировать объект
3. Правило перехода *(когда происходит определенное действие, в какое состояние объект перейдет)*
4. Действия состояния *(то, что должно выполниться в результате возникновения события)*

### Роли объектов

1. Реальные объекты
2. Роли *(абстракции целей обозначенных человеком)*
3. Инциденты как объект *(абстракция чего-то случившегося)*
4. Объекты взаимодействия *(оъекты получаемые из отношений между другими объектами)*
5. Объекты спецификации *(для представления правил, стандартов, критериев)*

### Отношения между объектами

1. Использование *(старшинства)*
	* Воздействие *(активный объект)*
	* Исполнение *(только подвержен воздействию других обектов, пассивный объект)*
	* Посредничество *(может выступать в обоих ролях)*
2. Включений *(один объект включает в себя другой)*

### Классы

Это такая абстракция множества предметов реального мира, что все эти предметы обладают одними и теми же характеристиками и подчинены и согласовываются с одними и тем же набором правил и поведений.

#### Отношения 

1. Наследование
2. Использование на уровне классов
3. Включения
4. Мета-класс

**Домен** - отдельный реальный, гипотетический или абстрактный мир, населенный набором объектов, которые ведут себя характерными для домена правилами поведения 

Класс в одном домене не требует нахождения класса в другом домене

## Лекция 3

**Объявление** - сколько угодно<br>
**Определение** - только один раз

### Ссылка

Ни тип данных, ни данное. Это еще одно имя или alias какого-то данного.

```cpp
int i;
int& ai = i;
ai = 1; // i = 1
```

### Перегрузка функций

Нексколько функций с одним и тем же именем. Тип возвращаемого значение не влияет на перегрузку

```cpp
void sort(Array& Ar, int Key = 0); 
// Первые параметры не могут быть параметрами по умолчанию

sort(Mas); // Key = 0
```

### Лабораторная работа 1

Вьювер каркасной модели (3д фигура, можно 4). Вершины соединяются ребрами, получается каркасная модель. Надо поворачивать, переносить, масштабировать. Модель хранить в файле. Реализуем структурно. Оконный интерфейс. Домен интерфейс и домен это задача

## Лекция 4

* **struct** - все члены имеют уровень доступа public по умолчанию
* **union** - поля находятся в одной области памяти (небезопасно) *(не может быть базовым и производным классом)*
* **class** - все члены имеют уровен доступа private по умолчанию

```cpp
class <имяКласса> [:<списокБаз>]
{
private:               // Доступ только из других членов этого класса
    <списокЧленов>
protected:             // Доступ членам этого класса и производным от этого класса
    <списокЧленов>
public:                // Общий доступ
    <списокЧленов>     // Только методы
};
```

*Подход белого ящика (идем всегда от данных)*

### Если писать библиотеку для кого-то, то порядок другой:

1. `public`
2. `protected`
3. `private`

```cpp
// A.h
class A
{
private:
    int a;
public:
    int f();
};
```

```cpp
// A.cpp
[inline] int A::f()
{
    return this->a;
}
```

```cpp
A obj, *p;
obj.f();
p->f();
// .*, ->*
```

### Наследование

```cpp
class A
{
private:
    int a;
protected:
    int b;
public:
    int f();
};

class B : [private | protected | public] A 
// По умолчанию уровень доступа наследования private
{
private:
    int c;
protected:
    int d;
public:
    int g();
};
```

```cpp
B obj;
```

#### Доступ private

*При схеме private все члены класса наследуются с уровнем private.*

|private|protected|public
|---|---|---|
|a, c, b, f()|d|g()|

`g() не может обращаться только к a`

Класс ничего не знает о производных, поэтому `f()` не имеет доступ к `d` и `g()`

**Полная смена интерфейса**

#### Доступ protected

*Public члены базового класса получат доступ protected*

|private|protected|public
|---|---|---|
|a, c|f(), b, d|g()|

Производные классы от класса `B` будут иметь доступ к `f()`

#### Доступ public

*Все члены базового класса остаются при своих доступах*<br>
По пути расширения интерфейса (основная схема)

|private|protected|public
|---|---|---|
|a, c|b, d|f(), g()|

`using A::f()` - для методов private и protected для переопределения уровня доступа

### Конструктор

```cpp
<имяКласса>::<имяКласса>([<списокПараметров>])
    [:<разделИнициализации>]
{
    ...
}
```

**Конструктор вызывается не для объекта, а создает его.**

#### Модификаторы членов

```cpp
class A
{
private:
    int a;
    const int cb;
    static int sc; // Если это член класса, то надо ставить модификатор static
    const static int csd = 1;
public:
    A(int ia)
        : a(ia),   // OK! объект
          cb(ia),  // OK! константа
          sc(ia),  // NO! 
          csd(ia)  // Error! 
    {
        a = ia;   // OK!
        cb = ia;  // Изменять константу, когда объект создан нельзя (Error!)
        sc = ia;  // OK!
    }
};
```

В разделе инициализации обязательно инициализировать константы.

Инициализировать статические константы можно только при объявлении в классе

```cpp
int A::sc = 0; // рассматривается как инициализация
```

```cpp
class B
{
public:
    static int f(); // Статический метод может работать с полями класса
    int g() const;  // Метод можно перегрузить (для константного)
    int g();        // Для обычного объекта
};

B::f()
```

#### Приведение типов

`(<абстрактноеОписание>)<выражение>` - язык C<br>
`<тип>(<выражение>)` - язык C++

**Конструктор можно перегружать, он не может быть константным, статическим или виртуальным. Конструктор не наследуется**

#### Конструкторы создающиеся по умолчанию

Конструктор без параметров - **конструктор по умолчанию**<br>
**Конструктор копирования** - принимает const this

#### Конструктор копирования

По умолчанию: побайтово копирует<br>
Желательно всегда реализовывать

#### Конструктор переноса (познакомимся чуть позже)

#### Дилигирующий конструктор

```cpp
class A
{
public:
    A(int i) {...}
    A():A(0) {...} // Один конструктор вызывает другой конструктор
};
```

#### Наследование конструктора

```cpp
class A
{
public:
    A(int i);
};

class B : public A
{
public:
    using A::A; // Наследуются все конструкторы от A
};

B obj(2);       // Вызовется конструктор класса A
```

## Лекция 5

#### Конструктор с переменным числом параметров

```cpp
// Комплексное число
class Complex
{
private:
    double re, im;
public:
    Complex() : Complex(0, 0) {}
    Complex(double r) : Complex(r, 0) {}
    Complex(double r, double i);
    Complex(const Complex& c);          // Конструктор копирования
 // Complex(const Complex& c) = delete; // Удаление конструктора коп.
};
```

```cpp
Complex a(), v,
b1 = Complex(1.),           // Явный вызов конструктора
b2(2.),                     // Явный вызов конструктора
b3 = 3., b4 = {4.}, b5{5.}, // Неявный вызов конструктора (C++11)
c1 = Complex(6., 7.),
c2(8., 9.),
c3 = {10., 11.}, c4{12., 13.},
d1 = Complex(c1),           // Явный вызов конструктора копирования
d2(c2),                     // Явный вызов конструктора копирования
d3 = c3;                    // Неявный вызов конструктора копирования
```

```cpp
explicit // Запрещает неявный вызов конструктора
```

```cpp
class A
{
public:
    void f(int);
    void f(double) = delete; // Не будет неявного преобразования к int
    A(int);
    A() = default; // Конструктор по умолчанию
};
```

### Деструктор

```cpp
~Complex();
```

Не может быть константным. Можно вызвать явно, но **не надо**. Может быть виртуальным.

### Оператор new

```cpp
new <имяТипа>() // не только выделение памяти, но и создание объекта
new <имяТипа>[<размерность>] // Для нескольких объектов
```
### Оператор delete

```cpp
delete <указатель>      // Удаление одного
delete[] <указатель>    // Удаление нескольких
// Квадратные скобочки нужны для того, чтобы отработали деструкторы
```

```cpp
<тип> *<идефикатор> = new <имя>(); // []
```

### Наследование

В каких случаях создается иерархия классов:

1. Несколько классоб объединяем общей базой *(общая схема использования)*
2. Сходство между операциями
3. Два подмножества класса строятся в разной манере *(создаем производные классы)*
4. Класс фигурирует в двух несвязных между собой обсуждениях проекта

Если в базовом классе мы объявили метод, то в производном классе можно его объявить и он будет доминировать над базовым
база

Та база, которая находится в списке баз являются **прямыми базами**, прямая база может входить только один раз в производный класс

**Косвенная база** это прямая база прямой базы. Может входить в производный класс сколько угодно раз.

```
V   V
|   |
A   B
 \ /
  C
```

### Виртуальное наследование

```cpp
class V{...};
class A : virtual public V {...}; // Класс V входит только один раз
class B :         public V {...}; // Можно писать только один раз
class C : public A, public B {...}; // Очередность влияет
```

```
  V         V
 / \       / \
A   B     A   |
 \ /       \ /
  C         C
```

### Неоднозначности при множественном наследовании

```cpp
class A
{
public:
    int a;
    int (*b)();
    int f();
    int f(int);
    int g();
};

class B
{
    int a;
    int b;
public:
    int f();
    int g();
    int h();
    int h(int);
};

class C : public A, public B {};
```

```cpp
C c;
c.a = 1; // Ошибка
c.b();   // Ошибка
c.f();
c.f(1);
c.g = 2;
```

## Лекция 6

```cpp
class B. public V
{
protected:
    void _draw();
public:
    void draw()
    {
        v ::_draw();
        _draw();
    }
}
```

Испольуя указатель на класс, можно обратиться к любому полю.<br>
ООП - программирование без возможности выбора (switch)

```cpp
v *p = new A;
p->draw(); //вызовется класс В
```

```cpp
class A
{
public:
    virtual void f();
};
class B
{
public:
    void f() override/*обязательно писать*/ final/*в производных методах
    не сможем подменить этот метод*/; //подмена базового метода
};
```

Если класс абстрактный явно пишем модификатор abstruct. 

```cpp
A& index(A * vec, int i)
{
    return vec[i];
}
```

Объекты класса А имеют доступ ко всем членам класса В

```cpp
class A
{
}
class B
{
friend class A;
}
```

Дружба не наследуется (сын моего друга, мне не друг). Дружба не транзитивна.<br>
Можем сделать другом не весь класс, а только какой-то метод. 

```cpp
class A
{
public:
    int f();
}
class B
{
friend int A::f();
}
```

Нельзя!

```cpp
{
    A* p = new A;
    p->f();
    delete p;
}
```

### Перегрузка операторов

#### Нельзя: 

`. , * , :: , sizeof , typeid`

#### Можно:

`= , () , [] , -> , ->* , <знак>=`

Явное и неявное приведение типа это тоже оператор

```cpp
class Complex
{
private:
    double re, im;
public:
    Complex operator + (const Complex& C) const
    {
        return (this->re + C.re, this->im + C.im);
    }
};

Complex a, b;
c = a + b
```

Оператор `()` можно перегружать только один раз *(рассматривается только как бинарный, справа количество параметров (стек) не влияет)*

Оператор `->` будем часто использовать *(унарный оператор)* **Должен возращать указатель на объект**

```cpp
class A
{
public:
    int f();
};

class B
{
public:
    A* operator -> ();
};

B obj;
obj->f();
// (obj.operator->())->f();
```

```c
int f();
int (*pf)();
pf = f; // Имя любой функции это ее адрес в памяти
pf();   // Вызов функции по адресу
```

```cpp
int A::f();
int (A::*pf)();
pf = &A::f // взятие адреса для метода

A obj, *p = &obj;
(obj.*pf)(); // вызов указателя на функцию из объекта
(p->*pf)(); // вызов указателя на функцию из указателя
```

