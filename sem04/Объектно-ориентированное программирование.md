# Объектно-ориентированное программирование

**Тассов Кирилл Леонидович**

## Лекция 1

### Структурное программирование

* Нисходящая разработка
* Использование базовых логических структур
* Сквозной структурный контроль

`вход → f → выход`<br>
Мы думаем что они делают, а не как они это делают.

Разработка разбивает на подзадачи (↓)<br>
Логика совмещает (↑)<br>
Данные приблизить к действию (↓)

#### Что дает эта технология

* Логические ошибки исправляются на ранних стадиях
* За счет упрощения абстракции упрощается написание кода
* Повышается надежность программного продукта
* Повторное использование кода
* Плавное распределение ресурсов при разработке ПО
* Упрощается сопровождение кода
* Возникает много естественных контрольных точек

## Лекция 2

### Инкапсуляция

**Инкапсуляция** – это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали 
реализации от пользователя.

Внесение изменений в написанный код - это понижение надежности

### Наследование

**Наследование** – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциольностью. Класс, от которого производится наследование, называется базовым или родительским. Новый класс – потомком, наследником или производным классом.

### Типы взаимодействий по Хоару

1. Синхронное взаимодействие *(процессорное)*
2. Событийное взаимодействие *(асинхронное)*

**Объект** - конкретная реализация какого-либо понятия, обладающая характеристиками состояния, поведения, индивидуальности.

* __Состояние__ - один из возможных варианта существования объекта
* __Поведение__ - описание объекта в терминах изменения его состояний и передачи сообщений данных в процессе воздействия или под воздействием других объектов
* __Индивидуальность__ - сущность объекта, отличающего его от других объектов

### Модель состояний Мура

Формировать жизненный цикл объекта

1. Выделяем множество состояний в которых может находится объект
2. Выделяем множество событий на которые может реагировать объект
3. Правило перехода *(когда происходит определенное действие, в какое состояние объект перейдет)*
4. Действия состояния *(то, что должно выполниться в результате возникновения события)*

### Роли объектов

1. Реальные объекты
2. Роли *(абстракции целей обозначенных человеком)*
3. Инциденты как объект *(абстракция чего-то случившегося)*
4. Объекты взаимодействия *(оъекты получаемые из отношений между другими объектами)*
5. Объекты спецификации *(для представления правил, стандартов, критериев)*

### Отношения между объектами

1. Использование *(старшинства)*
	* Воздействие *(активный объект)*
	* Исполнение *(только подвержен воздействию других обектов, пассивный объект)*
	* Посредничество *(может выступать в обоих ролях)*
2. Включений *(один объект включает в себя другой)*

### Классы

Это такая абстракция множества предметов реального мира, что все эти предметы обладают одними и теми же характеристиками и подчинены и согласовываются с одними и тем же набором правил и поведений.

#### Отношения 

1. Наследование
2. Использование на уровне классов
3. Включения
4. Мета-класс

**Домен** - отдельный реальный, гипотетический или абстрактный мир, населенный набором объектов, которые ведут себя характерными для домена правилами поведения 

Класс в одном домене не требует нахождения класса в другом домене

## Лекция 3

**Объявление** - сколько угодно<br>
**Определение** - только один раз

### Ссылка

Ни тип данных, ни данное. Это еще одно имя или alias какого-то данного.

```cpp
int i;
int& ai = i;
ai = 1; // i = 1
```

### Перегрузка функций

Нексколько функций с одним и тем же именем. Тип возвращаемого значение не влияет на перегрузку

```cpp
void sort(Array& Ar, int Key = 0); 
// Первые параметры не могут быть параметрами по умолчанию

sort(Mas); // Key = 0
```

### Лабораторная работа 1

Вьювер каркасной модели (3д фигура, можно 4). Вершины соединяются ребрами, получается каркасная модель. Надо поворачивать, переносить, масштабировать. Модель хранить в файле. Реализуем структурно. Оконный интерфейс. Домен интерфейс и домен это задача

## Лекция 4

* **struct** - все члены имеют уровень доступа public по умолчанию
* **union** - поля находятся в одной области памяти (небезопасно) *(не может быть базовым и производным классом)*
* **class** - все члены имеют уровен доступа private по умолчанию

```cpp
class <имяКласса> [:<списокБаз>]
{
private:               // Доступ только из других членов этого класса
    <списокЧленов>
protected:             // Доступ членам этого класса и производным от этого класса
    <списокЧленов>
public:                // Общий доступ
    <списокЧленов>     // Только методы
};
```

*Подход белого ящика (идем всегда от данных)*

### Если писать библиотеку для кого-то, то порядок другой:

1. `public`
2. `protected`
3. `private`

```cpp
// A.h
class A
{
private:
    int a;
public:
    int f();
};
```

```cpp
// A.cpp
[inline] int A::f()
{
    return this->a;
}
```

```cpp
A obj, *p;
obj.f();
p->f();
// .*, ->*
```

### Наследование

```cpp
class A
{
private:
    int a;
protected:
    int b;
public:
    int f();
};

class B : [private | protected | public] A 
// По умолчанию уровень доступа наследования private
{
private:
    int c;
protected:
    int d;
public:
    int g();
};
```

```cpp
B obj;
```

#### Доступ private

*При схеме private все члены класса наследуются с уровнем private.*

|private|protected|public
|---|---|---|
|a, c, b, f()|d|g()|

`g() не может обращаться только к a`

Класс ничего не знает о производных, поэтому `f()` не имеет доступ к `d` и `g()`

**Полная смена интерфейса**

#### Доступ protected

*Public члены базового класса получат доступ protected*

|private|protected|public
|---|---|---|
|a, c|f(), b, d|g()|

Производные классы от класса `B` будут иметь доступ к `f()`

#### Доступ public

*Все члены базового класса остаются при своих доступах*<br>
По пути расширения интерфейса (основная схема)

|private|protected|public
|---|---|---|
|a, c|b, d|f(), g()|

`using A::f()` - для методов private и protected для переопределения уровня доступа

### Конструктор

```cpp
<имяКласса>::<имяКласса>([<списокПараметров>])
    [:<разделИнициализации>]
{
    ...
}
```

**Конструктор вызывается не для объекта, а создает его.**

#### Модификаторы членов

```cpp
class A
{
private:
    int a;
    const int cb;
    static int sc; // Если это член класса, то надо ставить модификатор static
    const static int csd = 1;
public:
    A(int ia)
        : a(ia),   // OK! объект
          cb(ia),  // OK! константа
          sc(ia),  // NO! 
          csd(ia)  // Error! 
    {
        a = ia;   // OK!
        cb = ia;  // Изменять константу, когда объект создан нельзя (Error!)
        sc = ia;  // OK!
    }
};
```

В разделе инициализации обязательно инициализировать константы.

Инициализировать статические константы можно только при объявлении в классе

```cpp
int A::sc = 0; // рассматривается как инициализация
```

```cpp
class B
{
public:
    static int f(); // Статический метод может работать с полями класса
    int g() const;  // Метод можно перегрузить (для константного)
    int g();        // Для обычного объекта
};

B::f()
```

#### Приведение типов

`(<абстрактноеОписание>)<выражение>` - язык C<br>
`<тип>(<выражение>)` - язык C++

**Конструктор можно перегружать, он не может быть константным, статическим или виртуальным. Конструктор не наследуется**

#### Конструкторы создающиеся по умолчанию

Конструктор без параметров - **конструктор по умолчанию**<br>
**Конструктор копирования** - принимает const this

#### Конструктор копирования

По умолчанию: побайтово копирует<br>
Желательно всегда реализовывать

#### Конструктор переноса (познакомимся чуть позже)

#### Дилигирующий конструктор

```cpp
class A
{
public:
    A(int i) {...}
    A():A(0) {...} // Один конструктор вызывает другой конструктор
};
```

#### Наследование конструктора

```cpp
class A
{
public:
    A(int i);
};

class B : public A
{
public:
    using A::A; // Наследуются все конструкторы от A
};

B obj(2);       // Вызовется конструктор класса A
```

## Лекция 5

#### Конструктор с переменным числом параметров

```cpp
// Комплексное число
class Complex
{
private:
    double re, im;
public:
    Complex() : Complex(0, 0) {}
    Complex(double r) : Complex(r, 0) {}
    Complex(double r, double i);
    Complex(const Complex& c);          // Конструктор копирования
 // Complex(const Complex& c) = delete; // Удаление конструктора коп.
};
```

```cpp
Complex a(), v,
b1 = Complex(1.),           // Явный вызов конструктора
b2(2.),                     // Явный вызов конструктора
b3 = 3., b4 = {4.}, b5{5.}, // Неявный вызов конструктора (C++11)
c1 = Complex(6., 7.),
c2(8., 9.),
c3 = {10., 11.}, c4{12., 13.},
d1 = Complex(c1),           // Явный вызов конструктора копирования
d2(c2),                     // Явный вызов конструктора копирования
d3 = c3;                    // Неявный вызов конструктора копирования
```

```cpp
explicit // Запрещает неявный вызов конструктора
```

```cpp
class A
{
public:
    void f(int);
    void f(double) = delete; // Не будет неявного преобразования к int
    A(int);
    A() = default; // Конструктор по умолчанию
};
```

### Деструктор

```cpp
~Complex();
```

Не может быть константным. Можно вызвать явно, но **не надо**. Может быть виртуальным.

### Оператор new

```cpp
new <имяТипа>() // не только выделение памяти, но и создание объекта
new <имяТипа>[<размерность>] // Для нескольких объектов
```
### Оператор delete

```cpp
delete <указатель>      // Удаление одного
delete[] <указатель>    // Удаление нескольких
// Квадратные скобочки нужны для того, чтобы отработали деструкторы
```

```cpp
<тип> *<идефикатор> = new <имя>(); // []
```

### Наследование

В каких случаях создается иерархия классов:

1. Несколько классоб объединяем общей базой *(общая схема использования)*
2. Сходство между операциями
3. Два подмножества класса строятся в разной манере *(создаем производные классы)*
4. Класс фигурирует в двух несвязных между собой обсуждениях проекта

Если в базовом классе мы объявили метод, то в производном классе можно его объявить и он будет доминировать над базовым
база

Та база, которая находится в списке баз являются **прямыми базами**, прямая база может входить только один раз в производный класс

**Косвенная база** это прямая база прямой базы. Может входить в производный класс сколько угодно раз.

```
V   V
|   |
A   B
 \ /
  C
```

### Виртуальное наследование

```cpp
class V{...};
class A : virtual public V {...}; // Класс V входит только один раз
class B :         public V {...}; // Можно писать только один раз
class C : public A, public B {...}; // Очередность влияет
```

```
  V         V
 / \       / \
A   B     A   |
 \ /       \ /
  C         C
```

### Неоднозначности при множественном наследовании

```cpp
class A
{
public:
    int a;
    int (*b)();
    int f();
    int f(int);
    int g();
};

class B
{
    int a;
    int b;
public:
    int f();
    int g();
    int h();
    int h(int);
};

class C : public A, public B {};
```

```cpp
C c;
c.a = 1; // Ошибка
c.b();   // Ошибка
c.f();
c.f(1);
c.g = 2;
```

## Лекция 6

```cpp
class B. public V
{
protected:
    void _draw();
public:
    void draw()
    {
        v ::_draw();
        _draw();
    }
}
```

Испольуя указатель на класс, можно обратиться к любому полю.<br>
ООП - программирование без возможности выбора (switch)

```cpp
v *p = new A;
p->draw(); //вызовется класс В
```

```cpp
class A
{
public:
    virtual void f();
};
class B
{
public:
    void f() override/*обязательно писать*/ final/*в производных методах
    не сможем подменить этот метод*/; //подмена базового метода
};
```

Если класс абстрактный явно пишем модификатор abstruct. 

```cpp
A& index(A * vec, int i)
{
    return vec[i];
}
```

Объекты класса А имеют доступ ко всем членам класса В

```cpp
class A
{
}
class B
{
friend class A;
}
```

Дружба не наследуется (сын моего друга, мне не друг). Дружба не транзитивна.<br>
Можем сделать другом не весь класс, а только какой-то метод. 

```cpp
class A
{
public:
    int f();
}
class B
{
friend int A::f();
}
```

Нельзя!

```cpp
{
    A* p = new A;
    p->f();
    delete p;
}
```

### Перегрузка операторов

#### Нельзя: 

`. , * , :: , sizeof , typeid`

#### Можно:

`= , () , [] , -> , ->* , <знак>=`

Явное и неявное приведение типа это тоже оператор

```cpp
class Complex
{
private:
    double re, im;
public:
    Complex operator + (const Complex& C) const
    {
        return (this->re + C.re, this->im + C.im);
    }
};

Complex a, b;
c = a + b
```

Оператор `()` можно перегружать только один раз *(рассматривается только как бинарный, справа количество параметров (стек) не влияет)*

Оператор `->` будем часто использовать *(унарный оператор)* **Должен возращать указатель на объект**

```cpp
class A
{
public:
    int f();
};

class B
{
public:
    A* operator -> ();
};

B obj;
obj->f();
// (obj.operator->())->f();
```

```c
int f();
int (*pf)();
pf = f; // Имя любой функции это ее адрес в памяти
pf();   // Вызов функции по адресу
```

```cpp
int A::f();
int (A::*pf)();
pf = &A::f // взятие адреса для метода

A obj, *p = &obj;
(obj.*pf)(); // вызов указателя на функцию из объекта
(p->*pf)(); // вызов указателя на функцию из указателя
```

## Лекция 7

```cpp
class MyInt
{
private:
    int i = 0;
public:
    MyInt& operator++() // Префиксный ++оператор
    {
        ++i;
        return *this;
    }
    
    MyInt operator++(int) // Постфиксный оператор++
    {
        MyInt temp(i);
        i++;
        return temp;
    }
};

MyInt i;
++i; // MyInt& operator++()
i++; // MyInt operator++(int)
```


### Приведение типов

```cpp
class A
{
private:
    int i = 0;
public:
    operator bool()
    {
        return i == 0;
    }
};

A obj;
if (obj)
```

```cpp
class A
{
private:
    int i = 0;
public:
    explicit operator bool()
    {
        return i == 0;
    }
};

A obj;
if (obj)        // Нельзя
if (bool(obj))  // Только явно
```

### Временный объект

```cpp
Vector v1, v2, v3;
v1 = v2 + v3; // Создается временный объект 
```

### Копирование и перенос

```cpp
class Vector
{
private:
    double* ar;
    int count;
    static void copy(Vector& v1, const Vector& v2);
public:
    Vector(const Vector& v);                // Копирование
    Vector(Vector&& v);                     // Перенос
    Vector& operator= (const Vector& v);    // Копирование
    Vector& operator= (Vector&& v);         // Перенос
};

Vector::Vector(const Vector& v)
{
    copy(*this, v);
}

Vector::Vector(Vector&& v)
{
    this->count = v.count;
    this->ar = v.ar;
    v.ar = nullptr;
}

// a = b; копируем объект b в объект a
Vector& Vector::operator= (const Vector& v)
{
    delete[] this->ar;
    copy(*this, v);
}

// a = b + c; переносим временный объект b+c в объект a
Vector& Vector::operator= (Vector&& v)
{
    delete[] this->ar;
    this->count = v.count;
    this->ar = v.ar;
    v.ar = nullptr;
}

void Vector::copy(Vector& v1, const Vector& v2)
{
    v1.count = v2.count;
    v1.ar = new double[v1.count];
    for (int i = 0; i < v1.count; i++)
        v1.ar[i] = v2.ar[i];
}
```

### Обработка исключительных ситуаций

```cpp
try
{
    throw <тип>(<параметр>)
}
catch(<тип>& <переменная>)
```

```cpp
class A
{
public:
    void f() noexcept
    // noexcept(true)
    // noexcept(false)
    // throw(<тип>) функция может сгенерировать искл. ситуацию
};
```

### std::exception

```cpp
class MyException : public std::exception
{
public:
    virtual const char* what(const char* msg) const noexcept;
};
```


### Шаблоны

```cpp
template<сlass | typename <параметр> >
```

```cpp
template <typename Type>
unsigned length(FILE* stream)
{
    return filelenght(fileno(stream)) / sizeof(Type);
}

size = length<double>(stream);
```

## Лекция 8

Можно также создавать шаблоны классов

```cpp
// Первый аргумент шаблона тип данных, второй - размер
template <typename T, size_t n>
class Vector
{
private:
    T ar[n];
    size_t size = n;
public:
    Vector();
    size_t count();
    ...
};

template <typename T, size_t n>
Vector<T, n>::Vector() {}
```

Все шаблонные методы мы вынуждены описывать в **заголовочном файле**, поскольку только **во время использования** мы можем скомпилировать файл, узнав какой тип данных будем использовать

**Базовый класс** - нешаблонный

### Полная или частичная специализация

#### Полная специализация

```cpp
template <>
class Vector<double, 5>         // Пример полной специализации
{};
```

#### Создание объекта

```cpp
Vector<int, 2> v;
```

Шаблон не накладывает никаких ограничений на типы данных

#### Частичная специализация

```cpp
template <typename T1, typename T2>
class A {...};

template <typename T>
class A<T, T> {...};

template <typename T>
class A<T, int> {...};

template <typename T1, typename T2>
class A<T1*, T2*> {...};
```

Проверка начинается со специализаций

```cpp
A<int, float> a1;       // Ни одна специализация не подошла
A<float, float> a2;     // A<T, T>
A<float, int> a3;       // A<T, int>
A<int*, float*> a4;     // A<T1*, T2*>
A<int, int> a5;         // Неоднозначность (Error) (A<T, T>, A<T, int>)
A<int*, int*> a6;       // Неоднозначность (Error) (A<T, T>, A<T1*, T2*>)
```

### Параметры шаблона по умолчанию

```cpp
template <typename T1, typename T2 = float>
classA {...};

A<float> a1;
a<float, int> a2;
```

Параметры по умолчанию должны быть **последними** в списке шаблонов

### Шаблоны с переменным числом параметров

```cpp
template<typename T1, typename ...Args>
T sum(T v1, T v2, Args... args)
{
    return v2 + sum(v2, args...);
}

template <typename T>
T sum (T v)
{ return v; }
```

```cpp
template <typename T1, template T2>
// Будет возращать тип выражения x + y
auto sum (T1 x, T2 y) -> decltype(x + y)
{
    return x + y;
}

auto obj = <выражение>;
```

### Пространство имени

```cpp
namespace <имя>
{
    int f();
}
```

#### Обращение 

```cpp
<имя>::f();
```

#### Определение пространства имен

```cpp
using namespace <имя>;
f();
```

```cpp
{
    A* p = new A;
    p->f();
    delete p;
}
```

### Оболочка указателей

```cpp
{
    Holder <A> obj(new A);
    obj->f();
}
```

3 умных указателя в c++11

### Хранители (умные указатели)

```cpp
unique_ptr<тип> // Легкая прозрачная оболочка
```

`unique_ptr` обеспечивает строгое владение указателя *(он за него отвечает)*<br>
Можно передать указатель другому хранителю *(не обязательно `unique_ptr`)*

```cpp
std::unique_ptr<A> obj(new A);
std::unique_ptr<A> obj2(std::move(obj1)); // Передача владения
obj1 = obg2 // Нельзя!
pbj2 = std::move(obj1);
```

Перегружены операторы `->, *, bool(), []`

#### Совместное владение


```cpp
shared_ptr<A> obj(new A) // Позволяет копирование
```

Создать библиотечный шаблоный контейнерный класс(4 варианта)

1. Вектор математический
2. Множество (каждый элемент уникален)
3. Список прямого доступа
4. Матрица

`Nжурнала - 1 % 4 + 1`

1. Контейнерный класс
2. Операции
3. Просматривать содержимое в контейнере по итератору a[i]
4. Интерфейс должен быть избыточным

## Лекция 9

#### Мягкое владение

```cpp
weak_ptr<A>
```

### Список

```cpp
struct List
{
    Node* First, *Last;
};

struct Iterator
{
    Node* Current;
};
```

### Шаблоны и паттерны проектирования

* Порождающие
* Поведения
* Структурные


### Порождающие паттерны

#### Методы решения проблем

* **Фабричный метод** - создать объект

```cpp
class AbstractCreator
{
public:
    virtual unique_ptr<Product>;
    CreateProduct() = 0;
};

template <typename TProd>
class ConCreator : public AbstractCreator
{
public:
    virtual unique_ptr<Product> CreateProduct() override
    {
        return unique_ptr<Product>(new Tprod());
    }
};
```

```cpp
class Creator
{
public:
    shared_ptr<Product> GetProduct();
protected:
    virtual shared_ptr<Product> CreateProduct() = 0;
private:
    shared_ptr<Product> product;
};

shared_ptr<Product> Creator::GetProduct()
{
    if (product)
        product = CreateProduct();
    return product;
}
```

* **Абстрактная фабрика** - создавать объекты разных классов, но связанных между собой

* **Прототип** - реализуют метод, который называют `clone`, на основе которого создают новый объект

```cpp
class Prototype
{
public:
    virtual unique_ptr<Prototype> Clone() = 0;
};
```

* **Строитель** - 

## Лекция 9

```cpp
template<typename Type>
class Singleton
{
public:
    static Type& instance()
    {
        return *myInstance > myInstance(myInstance = new Type());
    }
    Singleton() = delete;
    Singleton<Type>& operator=(const Singleton<Type>&) = delete;
    Singleton(const Singleton<Type>&) = delete;
private:
    static Type* myInstance = nullptr;
};
```

## Лекция 10

```
Command
Execute()
^
|
|-----------------
|                |
ConCom1         ConComN
Execute(). ...  Execute()
```

```cpp
class Command
{
public:
    virtyal void execute() = 0;
};

template <typename Receiver>
class SimpleCom : public Command
{
public:
    typedef void (Receiver::*Action)();
    SimpleCom(shared_ptr<Receiver> r, Action a);
    void execute() override
    {
        ((*_r).*_a)();
    }
private:
    shared_ptr<Receive> _r;
    Action _a;
};
```

### Цепочка обязаностей

Что-то выполнили и перешли по цепочки к следующему. Есть базовый класс, задача которого вызвать действия производного класса, который выполняет действия и следующий переход (список в структуре класса)


```
Handler
Handle()
^
|
|
Handler1
Handle() ...
```

```cpp
class Handler
{
public:
    void add(shared_ptr<Handler> elem)
    {
        if (next)
            next->add(elem);
        else
            next = elem;
    }
    
    virtual void handle()
    {
        if (next)
            next->handle();
    }
private:
    shared_ptr<Handler> next;
};

class Handler1 : public Handler
{
public:
    void handle() override
    {
        if (brew services start httpd)
    }
};
```

### Подписчик-издатель

```
Object1         --->    Mediator    --->    Object2
Interface1()            Retrive()           Interface2()
                            ^
                            |
                            |
                          Client
```


### Паттерн состояния

Держит состояние объекта, используется в 3 лр, Входит в **КМС** - конечная модель состояния - паттерн проектирования

### Паттерн визитер

Посетитель

### Паттерн итератор

### Паттерн индексатор

### Паттерн интерпретатор


## Объектно-ориентированный анализ

### Этапы

1. Анализ
2. Проектирование
3. Эволюция
4. Модификация

Можно вернуться на предыдущий этап

1. Схема доменов
2. Проектная матрица
3. Модель связей подсистем
4. Модель взаимодействия подсистем
5. Модель доступа и подсистем
6. Информационная модель
7. Описани классов и атрибутов
8. Описание связей
9. Модель взаимодействия объектов
10. Состояние объекта
11. Список событий
12. Модель доступа к объекту
13. Таблица процессов состояний
14. Модель (переходов) состояний

4 лабораторная - 1 работа, реализовать объектами, построить модель(выделить сущности, формализация (отношения), посредники). Задача рассмотрения одного объекта, но возможно появление нескольких, даже групп