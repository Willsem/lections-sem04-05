# Объектно-ориентированное программирование

**Тассов Кирилл Леонидович**

## Лекция 1

### Структурное программирование

* Нисходящая разработка
* Использование базовых логических структур
* Сквозной структурный контроль

`вход → f → выход`<br>
Мы думаем что они делают, а не как они это делают.

Разработка разбивает на подзадачи (↓)<br>
Логика совмещает (↑)<br>
Данные приблизить к действию (↓)

#### Что дает эта технология

* Логические ошибки исправляются на ранних стадиях
* За счет упрощения абстракции упрощается написание кода
* Повышается надежность программного продукта
* Повторное использование кода
* Плавное распределение ресурсов при разработке ПО
* Упрощается сопровождение кода
* Возникает много естественных контрольных точек

## Лекция 2

### Инкапсуляция

**Инкапсуляция** – это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали 
реализации от пользователя.

Внесение изменений в написанный код - это понижение надежности

### Наследование

**Наследование** – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциольностью. Класс, от которого производится наследование, называется базовым или родительским. Новый класс – потомком, наследником или производным классом.

### Типы взаимодействий по Хоару

1. Синхронное взаимодействие *(процессорное)*
2. Событийное взаимодействие *(асинхронное)*

**Объект** - конкретная реализация какого-либо понятия, обладающая характеристиками состояния, поведения, индивидуальности.

* __Состояние__ - один из возможных варианта существования объекта
* __Поведение__ - описание объекта в терминах изменения его состояний и передачи сообщений данных в процессе воздействия или под воздействием других объектов
* __Индивидуальность__ - сущность объекта, отличающего его от других объектов

### Модель состояний Мура

Формировать жизненный цикл объекта

1. Выделяем множество состояний в которых может находится объект
2. Выделяем множество событий на которые может реагировать объект
3. Правило перехода *(когда происходит определенное действие, в какое состояние объект перейдет)*
4. Действия состояния *(то, что должно выполниться в результате возникновения события)*

### Роли объектов

1. Реальные объекты
2. Роли *(абстракции целей обозначенных человеком)*
3. Инциденты как объект *(абстракция чего-то случившегося)*
4. Объекты взаимодействия *(оъекты получаемые из отношений между другими объектами)*
5. Объекты спецификации *(для представления правил, стандартов, критериев)*

### Отношения между объектами

1. Использование *(старшинства)*
	* Воздействие *(активный объект)*
	* Исполнение *(только подвержен воздействию других обектов, пассивный объект)*
	* Посредничество *(может выступать в обоих ролях)*
2. Включений *(один объект включает в себя другой)*

### Классы

Это такая абстракция множества предметов реального мира, что все эти предметы обладают одними и теми же характеристиками и подчинены и согласовываются с одними и тем же набором правил и поведений.

#### Отношения 

1. Наследование
2. Использование на уровне классов
3. Включения
4. Мета-класс

**Домен** - отдельный реальный, гипотетический или абстрактный мир, населенный набором объектов, которые ведут себя характерными для домена правилами поведения 

Класс в одном домене не требует нахождения класса в другом домене

## Лекция 3

**Объявление** - сколько угодно<br>
**Определение** - только один раз

### Ссылка

Ни тип данных, ни данное. Это еще одно имя или alias какого-то данного.

```cpp
int i;
int& ai = i;
ai = 1; // i = 1
```

### Перегрузка функций

Нексколько функций с одним и тем же именем. Тип возвращаемого значение не влияет на перегрузку

```cpp
void sort(Array& Ar, int Key = 0); 
// Первые параметры не могут быть параметрами по умолчанию

sort(Mas); // Key = 0
```

### Лабораторная работа 1

Вьювер каркасной модели (3д фигура, можно 4). Вершины соединяются ребрами, получается каркасная модель. Надо поворачивать, переносить, масштабировать. Модель хранить в файле. Реализуем структурно. Оконный интерфейс. Домен интерфейс и домен это задача

## Лекция 4

* **struct** - все члены имеют уровень доступа public по умолчанию
* **union** - поля находятся в одной области памяти (небезопасно) *(не может быть базовым и производным классом)*
* **class** - все члены имеют уровен доступа private по умолчанию

```cpp
class <имяКласса> [:<списокБаз>]
{
private:               // Доступ только из других членов этого класса
    <списокЧленов>
protected:             // Доступ членам этого класса и производным от этого класса
    <списокЧленов>
public:                // Общий доступ
    <списокЧленов>     // Только методы
};
```

*Подход белого ящика (идем всегда от данных)*

### Если писать библиотеку для кого-то, то порядок другой:

1. `public`
2. `protected`
3. `private`

```cpp
// A.h
class A
{
private:
    int a;
public:
    int f();
};
```

```cpp
// A.cpp
[inline] int A::f()
{
    return this->a;
}
```

```cpp
A obj, *p;
obj.f();
p->f();
// .*, ->*
```

### Наследование

```cpp
class A
{
private:
    int a;
protected:
    int b;
public:
    int f();
};

class B : [private | protected | public] A 
// По умолчанию уровень доступа наследования private
{
private:
    int c;
protected:
    int d;
public:
    int g();
};
```

```cpp
B obj;
```

#### Доступ private

*При схеме private все члены класса наследуются с уровнем private.*

|private|protected|public
|---|---|---|
|a, c, b, f()|d|g()|

`g() не может обращаться только к a`

Класс ничего не знает о производных, поэтому `f()` не имеет доступ к `d` и `g()`

**Полная смена интерфейса**

#### Доступ protected

*Public члены базового класса получат доступ protected*

|private|protected|public
|---|---|---|
|a, c|f(), b, d|g()|

Производные классы от класса `B` будут иметь доступ к `f()`

#### Доступ public

*Все члены базового класса остаются при своих доступах*<br>
По пути расширения интерфейса (основная схема)

|private|protected|public
|---|---|---|
|a, c|b, d|f(), g()|

`using A::f()` - для методов private и protected для переопределения уровня доступа

### Конструктор

```cpp
<имяКласса>::<имяКласса>([<списокПараметров>])
    [:<разделИнициализации>]
{
    ...
}
```

**Конструктор вызывается не для объекта, а создает его.**

#### Модификаторы членов

```cpp
class A
{
private:
    int a;
    const int cb;
    static int sc; // Если это член класса, то надо ставить модификатор static
    const static int csd = 1;
public:
    A(int ia)
        : a(ia),   // OK! объект
          cb(ia),  // OK! константа
          sc(ia),  // NO! 
          csd(ia)  // Error! 
    {
        a = ia;   // OK!
        cb = ia;  // Изменять константу, когда объект создан нельзя (Error!)
        sc = ia;  // OK!
    }
};
```

В разделе инициализации обязательно инициализировать константы.

Инициализировать статические константы можно только при объявлении в классе

```cpp
int A::sc = 0; // рассматривается как инициализация
```

```cpp
class B
{
public:
    static int f(); // Статический метод может работать с полями класса
    int g() const;  // Метод можно перегрузить (для константного)
    int g();        // Для обычного объекта
};

B::f()
```

#### Приведение типов

`(<абстрактноеОписание>)<выражение>` - язык C<br>
`<тип>(<выражение>)` - язык C++

**Конструктор можно перегружать, он не может быть константным, статическим или виртуальным. Конструктор не наследуется**

#### Конструкторы создающиеся по умолчанию

Конструктор без параметров - **конструктор по умолчанию**<br>
**Конструктор копирования** - принимает const this

#### Конструктор копирования

По умолчанию: побайтово копирует<br>
Желательно всегда реализовывать

#### Конструктор переноса (познакомимся чуть позже)

#### Дилигирующий конструктор

```cpp
class A
{
public:
    A(int i) {...}
    A():A(0) {...} // Один конструктор вызывает другой конструктор
};
```

#### Наследование конструктора

```cpp
class A
{
public:
    A(int i);
};

class B : public A
{
public:
    using A::A; // Наследуются все конструкторы от A
};

B obj(2);       // Вызовется конструктор класса A
```
